{"ast":null,"code":"import { isActionEquals, players as actions } from './actions';\nimport { isCellEqual, getWrappingCells, findActionsOnCell } from './utils/tiles';\nexport const pass = (store, action) => {\n  const previousState = store.getState();\n  const firstPlayerIndex = previousState.players.findIndex(({\n    first\n  }) => first);\n  const currentPlayerIndex = previousState.players.findIndex(({\n    current\n  }) => current);\n\n  const getNextIndex = current => {\n    const next = current + 1;\n\n    if (next >= previousState.players.length) {\n      return 0;\n    }\n\n    return next;\n  };\n\n  const nextCurrentPlayerIndex = getNextIndex(currentPlayerIndex);\n  const turnEnd = firstPlayerIndex === nextCurrentPlayerIndex;\n  store.mutate(state => {\n    state.players[currentPlayerIndex].current = false;\n\n    if (turnEnd) {\n      state.players.forEach((player, index) => {\n        player.actionPoints = 2;\n      });\n      const nextFirstPlayerIndex = getNextIndex(firstPlayerIndex);\n      state.players[nextFirstPlayerIndex].current = true;\n      state.players[nextFirstPlayerIndex].first = true;\n      state.players[firstPlayerIndex].first = false;\n    } else {\n      state.players[nextCurrentPlayerIndex].current = true;\n    }\n  });\n  if (turnEnd) store.dispatch('@turn>start');\n};\nexport const move = (store, action) => {\n  store.mutate(state => {\n    if (!state.playerActions.possibilities.some(isActionEquals(action))) return;\n    const player = state.players.find(({\n      name\n    }) => name === action.payload.playerName);\n    player.actionPoints = Math.max(0, player.actionPoints - action.payload.cost);\n    player.x = action.payload.x;\n    player.y = action.payload.y;\n  });\n};\nexport const findPossibilities = (store, action) => {\n  store.mutate(state => {\n    const player = state.players.find(({\n      current\n    }) => current);\n    state.playerActions.possibilities = [];\n    if (player.actionPoints === 0 || player.health === 0) return; // TODO: We should add excess in another PR by filter all actions once they are created\n\n    const tile = state.grid.find(isCellEqual(player));\n    const playersOnCell = state.players.filter(isCellEqual(player)); // based actions\n    // TODO: clear / climb / etc\n\n    let commonActions = [// - heal\n    ...playersOnCell // some health is missing\n    .filter(({\n      health,\n      archetype\n    }) => health < archetype.health) // map it to an action\n    .map(currentPlayer => actions.heal(currentPlayer)) // TODO: We should add excess in another PR by filter all actions once they are created\n    ]; // actions on cells\n\n    const cells = getWrappingCells(state.grid);\n    const findPlayerActionsOnCell = findActionsOnCell(player, tile);\n    const cellsActions = cells.flatMap(findPlayerActionsOnCell); // actions based on skills\n\n    const skillsActions = []; // - heal\n\n    if (player.skills.some(({\n      type\n    }) => type === 'heal')) {\n      // this is already processed in common actions, we just lower the cost\n      commonActions = commonActions.map(currAction => {\n        if (currAction.type !== '@players>heal') return currAction;\n        if (currAction.payload.playerName === player.name) return currAction;\n        return { ...currAction,\n          payload: { ...currAction.payload,\n            cost: player.skills.find(({\n              type\n            }) => type === 'heal').cost // TODO: We should add excess in another PR by filter all actions once they are created\n\n          }\n        };\n      });\n    }\n\n    state.playerActions.possibilities = [...commonActions, ...skillsActions, ...cellsActions];\n  });\n};\nexport const damage = (store, action) => {\n  const prevState = store.getState();\n  const playerIndex = prevState.players.findIndex(({\n    name\n  }) => name === action.payload.playerName);\n  const prevPlayer = prevState.players[playerIndex];\n\n  const findProtect = skill => skill.type === 'protect'; // if the player does not have protect skill\n  // we try to find someone who has one the same tile\n\n\n  if (!prevPlayer.skills.some(findProtect)) {\n    const withProtect = prevState.players.find(player => isCellEqual(player)(prevPlayer) && player.health > 0 && player.skills.some(findProtect));\n\n    if (withProtect) {\n      store.dispatch({\n        type: '@players>protected',\n        payload: {\n          playerName: action.payload.playerName,\n          protectedBy: withProtect.name\n        }\n      });\n      return;\n    }\n  } // no one to protect the player, it takes damage\n\n\n  store.mutate(state => {\n    const player = state.players[playerIndex];\n    player.health = Math.max(0, player.health - action.payload.damage);\n\n    if (player.health <= 0) {\n      store.dispatch({\n        type: '@players>death',\n        payload: {\n          playerName: action.payload.playerName\n        }\n      });\n    }\n  });\n};\nexport const init = (store, action) => {\n  store.mutate(state => {\n    state.players = action.payload.map(player => ({ ...player,\n      x: 0,\n      y: 0,\n      actionPoints: 2\n    }));\n    state.players[0].current = true;\n    state.players[0].first = true;\n  });\n};\nexport const heal = (store, action) => {\n  const prevState = store.getState();\n\n  if (!prevState.playerActions.possibilities.some(isActionEquals(action))) {\n    return;\n  }\n\n  store.mutate(state => {\n    const player = state.players.find(({\n      name\n    }) => name === action.payload.playerName);\n    player.health = Math.min(player.health + action.payload.amount, player.archetype.health);\n    player.actionPoints = Math.max(0, player.actionPoints - action.payload.cost);\n  });\n};","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/packages/engine/src/players.js"],"names":["isActionEquals","players","actions","isCellEqual","getWrappingCells","findActionsOnCell","pass","store","action","previousState","getState","firstPlayerIndex","findIndex","first","currentPlayerIndex","current","getNextIndex","next","length","nextCurrentPlayerIndex","turnEnd","mutate","state","forEach","player","index","actionPoints","nextFirstPlayerIndex","dispatch","move","playerActions","possibilities","some","find","name","payload","playerName","Math","max","cost","x","y","findPossibilities","health","tile","grid","playersOnCell","filter","commonActions","archetype","map","currentPlayer","heal","cells","findPlayerActionsOnCell","cellsActions","flatMap","skillsActions","skills","type","currAction","damage","prevState","playerIndex","prevPlayer","findProtect","skill","withProtect","protectedBy","init","min","amount"],"mappings":"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","sourcesContent":["import { isActionEquals, players as actions } from './actions'\nimport { isCellEqual, getWrappingCells, findActionsOnCell } from './utils/tiles'\n\nexport const pass = (store, action) => {\n  const previousState = store.getState()\n  const firstPlayerIndex = previousState.players.findIndex(({ first }) => first)\n  const currentPlayerIndex = previousState.players.findIndex(\n    ({ current }) => current,\n  )\n\n  const getNextIndex = (current) => {\n    const next = current + 1\n    if (next >= previousState.players.length) {\n      return 0\n    }\n    return next\n  }\n\n  const nextCurrentPlayerIndex = getNextIndex(currentPlayerIndex)\n\n  const turnEnd = firstPlayerIndex === nextCurrentPlayerIndex\n\n  store.mutate((state) => {\n    state.players[currentPlayerIndex].current = false\n\n    if (turnEnd) {\n      state.players.forEach((player, index) => {\n        player.actionPoints = 2\n      })\n\n      const nextFirstPlayerIndex = getNextIndex(firstPlayerIndex)\n      state.players[nextFirstPlayerIndex].current = true\n      state.players[nextFirstPlayerIndex].first = true\n      state.players[firstPlayerIndex].first = false\n    } else {\n      state.players[nextCurrentPlayerIndex].current = true\n    }\n  })\n\n  if (turnEnd) store.dispatch('@turn>start')\n}\n\nexport const move = (store, action) => {\n  store.mutate((state) => {\n    if (!state.playerActions.possibilities.some(isActionEquals(action))) return\n\n    const player = state.players.find(\n      ({ name }) => name === action.payload.playerName,\n    )\n\n    player.actionPoints = Math.max(0, player.actionPoints - action.payload.cost)\n    player.x = action.payload.x\n    player.y = action.payload.y\n  })\n}\n\nexport const findPossibilities = (store, action) => {\n  store.mutate((state) => {\n    const player = state.players.find(({ current }) => current)\n    state.playerActions.possibilities = []\n\n    if (player.actionPoints === 0 || player.health === 0) return // TODO: We should add excess in another PR by filter all actions once they are created\n\n    const tile = state.grid.find(isCellEqual(player))\n    const playersOnCell = state.players.filter(isCellEqual(player))\n\n    // based actions\n    // TODO: clear / climb / etc\n    let commonActions = [\n      // - heal\n      ...playersOnCell\n        // some health is missing\n        .filter(({ health, archetype }) => health < archetype.health)\n        // map it to an action\n        .map((currentPlayer) => actions.heal(currentPlayer)), // TODO: We should add excess in another PR by filter all actions once they are created\n    ]\n\n    // actions on cells\n    const cells = getWrappingCells(state.grid)\n    const findPlayerActionsOnCell = findActionsOnCell(player, tile)\n    const cellsActions = cells.flatMap(findPlayerActionsOnCell)\n\n    // actions based on skills\n    const skillsActions = []\n    // - heal\n    if (player.skills.some(({ type }) => type === 'heal')) {\n      // this is already processed in common actions, we just lower the cost\n      commonActions = commonActions.map((currAction) => {\n        if (currAction.type !== '@players>heal') return currAction\n        if (currAction.payload.playerName === player.name) return currAction\n        return {\n          ...currAction,\n          payload: {\n            ...currAction.payload,\n            cost: player.skills.find(({ type }) => type === 'heal').cost, // TODO: We should add excess in another PR by filter all actions once they are created\n          },\n        }\n      })\n    }\n\n    state.playerActions.possibilities = [\n      ...commonActions,\n      ...skillsActions,\n      ...cellsActions,\n    ]\n  })\n}\n\nexport const damage = (store, action) => {\n  const prevState = store.getState()\n  const playerIndex = prevState.players.findIndex(\n    ({ name }) => name === action.payload.playerName,\n  )\n  const prevPlayer = prevState.players[playerIndex]\n\n  const findProtect = (skill) => skill.type === 'protect'\n\n  // if the player does not have protect skill\n  // we try to find someone who has one the same tile\n  if (!prevPlayer.skills.some(findProtect)) {\n    const withProtect = prevState.players.find(\n      (player) =>\n        isCellEqual(player)(prevPlayer) &&\n        player.health > 0 &&\n        player.skills.some(findProtect),\n    )\n\n    if (withProtect) {\n      store.dispatch({\n        type: '@players>protected',\n        payload: {\n          playerName: action.payload.playerName,\n          protectedBy: withProtect.name,\n        },\n      })\n\n      return\n    }\n  }\n\n  // no one to protect the player, it takes damage\n  store.mutate((state) => {\n    const player = state.players[playerIndex]\n    player.health = Math.max(0, player.health - action.payload.damage)\n\n    if (player.health <= 0) {\n      store.dispatch({\n        type: '@players>death',\n        payload: { playerName: action.payload.playerName },\n      })\n    }\n  })\n}\n\nexport const init = (store, action) => {\n  store.mutate((state) => {\n    state.players = action.payload.map((player) => ({\n      ...player,\n      x: 0,\n      y: 0,\n      actionPoints: 2,\n    }))\n    state.players[0].current = true\n    state.players[0].first = true\n  })\n}\n\nexport const heal = (store, action) => {\n  const prevState = store.getState()\n\n  if (!prevState.playerActions.possibilities.some(isActionEquals(action))) {\n    return\n  }\n\n  store.mutate((state) => {\n    const player = state.players.find(\n      ({ name }) => name === action.payload.playerName,\n    )\n    player.health = Math.min(\n      player.health + action.payload.amount,\n      player.archetype.health,\n    )\n    player.actionPoints = Math.max(0, player.actionPoints - action.payload.cost)\n  })\n}\n"]},"metadata":{},"sourceType":"module"}