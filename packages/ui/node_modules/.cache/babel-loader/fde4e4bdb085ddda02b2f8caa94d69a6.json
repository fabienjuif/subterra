{"ast":null,"code":"const {\n  getFromPath\n} = require('@myrtille/util');\n\nconst connectToDevtools = require('./devtools');\n\nconst matchListener = (matcher, reaction) => (store, action, ...args) => {\n  if ( // string matcher\n  typeof matcher === 'string' && matcher === action.type || // function matcher\n  typeof matcher === 'function' && matcher(action, store) // object matcher (regexp or object)\n  || typeof matcher === 'object' && ( // object\n  matcher.type === action.type // regexp\n  || typeof matcher.test === 'function' && matcher.test(action.type))) reaction(store, action, ...args);\n};\n\nconst matchSubscriber = (path, callback) => (store, oldState, ...args) => {\n  const call = () => callback(store, oldState, ...args);\n\n  if (path === undefined || path.trim() === '') {\n    if (oldState !== store.getState()) call();\n  } else if (getFromPath(oldState, path) !== getFromPath(store.getState(), path)) {\n    call();\n  }\n};\n\nconst createStore = init => {\n  let store;\n  let state = init;\n  let subscribers = [];\n  let reactions = [];\n  let dispatching = false;\n  const nextDispatchs = [];\n\n  const runAndNotify = (implementation, action = {\n    type: '@@DIRECT_MUTATION'\n  }) => {\n    const oldState = store.getState();\n    implementation();\n    if (dispatching) return;\n\n    for (let i = 0; i < subscribers.length; i += 1) {\n      subscribers[i](store, oldState, action);\n    }\n  };\n\n  const dispatch = action => {\n    let innerAction = action;\n    if (typeof action === 'string') innerAction = {\n      type: action\n    };\n\n    if (dispatching) {\n      nextDispatchs.push(innerAction);\n      return;\n    }\n\n    runAndNotify(() => {\n      dispatching = true;\n\n      for (let i = 0; i < reactions.length; i += 1) {\n        reactions[i](store, innerAction);\n      }\n\n      dispatching = false;\n    }, innerAction);\n\n    if (nextDispatchs.length) {\n      const nextAction = nextDispatchs.shift();\n      dispatch(nextAction);\n    }\n  };\n\n  const removeListener = callback => {\n    reactions = reactions.filter(reaction => reaction !== callback);\n  };\n\n  const removeSubscriber = callback => {\n    subscribers = subscribers.filter(subscriber => subscriber !== callback);\n  };\n\n  const getState = () => state;\n\n  const setState = newState => {\n    runAndNotify(() => {\n      state = newState;\n    });\n  };\n\n  store = {\n    contexts: {},\n    setState,\n    getState,\n    dispatch,\n    addListener: (event, callback) => {\n      let newReaction;\n\n      if (callback === undefined) {\n        newReaction = event;\n      } else {\n        newReaction = matchListener(event, callback);\n      }\n\n      reactions = reactions.concat(newReaction);\n      return () => removeListener(newReaction);\n    },\n    subscribe: (path, callback) => {\n      let newSubscriber;\n\n      if (callback === undefined) {\n        newSubscriber = path;\n      } else {\n        newSubscriber = matchSubscriber(path, callback);\n      }\n\n      subscribers = subscribers.concat(newSubscriber);\n      return () => removeSubscriber(newSubscriber);\n    }\n  };\n  connectToDevtools(store);\n  return store;\n};\n\nmodule.exports = createStore;","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/node_modules/@myrtille/core/index.js"],"names":["getFromPath","require","connectToDevtools","matchListener","matcher","reaction","store","action","args","type","test","matchSubscriber","path","callback","oldState","call","undefined","trim","getState","createStore","init","state","subscribers","reactions","dispatching","nextDispatchs","runAndNotify","implementation","i","length","dispatch","innerAction","push","nextAction","shift","removeListener","filter","removeSubscriber","subscriber","setState","newState","contexts","addListener","event","newReaction","concat","subscribe","newSubscriber","module","exports"],"mappings":"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","sourcesContent":["const { getFromPath } = require('@myrtille/util')\nconst connectToDevtools = require('./devtools')\n\nconst matchListener = (matcher, reaction) => (store, action, ...args) => {\n  if (\n    // string matcher\n    (typeof matcher === 'string' && matcher === action.type)\n    // function matcher\n    || (typeof matcher === 'function' && matcher(action, store))\n    // object matcher (regexp or object)\n    || ((typeof matcher === 'object') && (\n      // object\n      matcher.type === action.type\n      // regexp\n      || (typeof matcher.test === 'function' && matcher.test(action.type))\n    ))\n  ) reaction(store, action, ...args)\n}\n\nconst matchSubscriber = (path, callback) => (store, oldState, ...args) => {\n  const call = () => callback(store, oldState, ...args)\n\n  if (path === undefined || path.trim() === '') {\n    if (oldState !== store.getState()) call()\n  } else if (getFromPath(oldState, path) !== getFromPath(store.getState(), path)) {\n    call()\n  }\n}\n\nconst createStore = (init) => {\n  let store\n  let state = init\n  let subscribers = []\n  let reactions = []\n  let dispatching = false\n  const nextDispatchs = []\n\n  const runAndNotify = (implementation, action = { type: '@@DIRECT_MUTATION' }) => {\n    const oldState = store.getState()\n\n    implementation()\n\n    if (dispatching) return\n\n    for (let i = 0; i < subscribers.length; i += 1) {\n      subscribers[i](store, oldState, action)\n    }\n  }\n\n  const dispatch = (action) => {\n    let innerAction = action\n    if (typeof action === 'string') innerAction = { type: action }\n\n    if (dispatching) {\n      nextDispatchs.push(innerAction)\n      return\n    }\n\n    runAndNotify(() => {\n      dispatching = true\n\n      for (let i = 0; i < reactions.length; i += 1) {\n        reactions[i](store, innerAction)\n      }\n\n      dispatching = false\n    }, innerAction)\n\n    if (nextDispatchs.length) {\n      const nextAction = nextDispatchs.shift()\n      dispatch(nextAction)\n    }\n  }\n\n  const removeListener = (callback) => {\n    reactions = reactions.filter((reaction) => reaction !== callback)\n  }\n\n  const removeSubscriber = (callback) => {\n    subscribers = subscribers.filter((subscriber) => subscriber !== callback)\n  }\n\n  const getState = () => state\n\n  const setState = (newState) => {\n    runAndNotify(() => {\n      state = newState\n    })\n  }\n\n  store = {\n    contexts: {},\n    setState,\n    getState,\n    dispatch,\n    addListener: (event, callback) => {\n      let newReaction\n      if (callback === undefined) {\n        newReaction = event\n      } else {\n        newReaction = matchListener(event, callback)\n      }\n\n      reactions = reactions.concat(newReaction)\n\n      return () => removeListener(newReaction)\n    },\n    subscribe: (path, callback) => {\n      let newSubscriber\n      if (callback === undefined) {\n        newSubscriber = path\n      } else {\n        newSubscriber = matchSubscriber(path, callback)\n      }\n\n      subscribers = subscribers.concat(newSubscriber)\n\n      return () => removeSubscriber(newSubscriber)\n    },\n  }\n\n  connectToDevtools(store)\n  return store\n}\n\nmodule.exports = createStore\n"]},"metadata":{},"sourceType":"script"}