{"ast":null,"code":"import { players, roll } from './actions';\nimport { isCellEqual } from './utils/tiles';\nexport const init = (store, action) => {\n  store.mutate(state => {\n    state.deckCards = action.payload;\n  });\n};\nexport const pick = (store, action) => {\n  store.mutate(state => {\n    if (state.deckCards.length > 0) {\n      state.activeCard = state.deckCards.shift();\n    }\n  });\n  const nextState = store.getState();\n  const {\n    type: cardType\n  } = nextState.activeCard;\n\n  if (['shake', 'water', 'gaz', 'enemy', 'end'].includes(cardType)) {\n    store.dispatch({\n      type: `@cards>${cardType}`,\n      payload: {\n        card: nextState.activeCard\n      }\n    });\n  } else if (cardType === 'landslide') {\n    store.dispatch(roll.then({\n      type: '@cards>landslide'\n    }));\n  }\n};\nexport const end = (store, action) => {\n  store.getState().players.forEach(player => {\n    if (player.health <= 0) return;\n    store.dispatch(roll.failThen(3, player, players.damage(player, 1000, {\n      from: {\n        card: action.payload.card\n      }\n    })));\n  });\n};\nexport const shake = (store, action) => {\n  const previousState = store.getState();\n  previousState.players.forEach(player => {\n    store.dispatch(roll.failThen(4, player, players.damage(player, previousState.activeCard.damage, {\n      card: previousState.activeCard\n    })));\n  });\n};\nexport const landslide = (store, action) => {\n  const {\n    activeCard\n  } = store.getState(); // find all tiles that are landslide and match the dice result\n  // tile should not be already in the landslide status\n  // add the status 'landslide' to these tiles\n  // and for each of these tiles, check a player is in it and damage it in this case\n\n  store.mutate(state => {\n    state.grid.forEach(tile => {\n      const {\n        type,\n        status,\n        dices\n      } = tile;\n      if (type !== 'landslide') return;\n      if (status.includes('landslide')) return;\n      if (!dices.includes(action.payload.rolled)) return;\n      tile.status.push('landslide');\n      state.players.forEach(player => {\n        if (!isCellEqual(player)(tile)) return;\n        store.dispatch(players.damage(player, activeCard.damage, {\n          card: activeCard\n        }));\n      });\n    });\n  });\n};\nexport const processMarkerCard = (store, action) => {\n  const {\n    card\n  } = action.payload; // find all tiles that have water type and put a status on it\n  // if it do not already exists\n  // if a player is in this tile then it take damage\n\n  store.mutate(state => {\n    state.grid.forEach(tile => {\n      const {\n        type,\n        status\n      } = tile;\n      if (type !== card.type) return;\n      if (status.includes(card.type)) return;\n      tile.status.push(card.type);\n      state.players.forEach(player => {\n        if (!isCellEqual(player)(tile)) return;\n        store.dispatch(players.damage(player, card.damage, {\n          card\n        }));\n      });\n    });\n  });\n};","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/packages/engine/src/cards.js"],"names":["players","roll","isCellEqual","init","store","action","mutate","state","deckCards","payload","pick","length","activeCard","shift","nextState","getState","type","cardType","includes","dispatch","card","then","end","forEach","player","health","failThen","damage","from","shake","previousState","landslide","grid","tile","status","dices","rolled","push","processMarkerCard"],"mappings":"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","sourcesContent":["import { players, roll } from './actions'\nimport { isCellEqual } from './utils/tiles'\n\nexport const init = (store, action) => {\n  store.mutate((state) => {\n    state.deckCards = action.payload\n  })\n}\n\nexport const pick = (store, action) => {\n  store.mutate((state) => {\n    if (state.deckCards.length > 0) {\n      state.activeCard = state.deckCards.shift()\n    }\n  })\n\n  const nextState = store.getState()\n  const { type: cardType } = nextState.activeCard\n  if (['shake', 'water', 'gaz', 'enemy', 'end'].includes(cardType)) {\n    store.dispatch({\n      type: `@cards>${cardType}`,\n      payload: { card: nextState.activeCard },\n    })\n  } else if (cardType === 'landslide') {\n    store.dispatch(roll.then({ type: '@cards>landslide' }))\n  }\n}\n\nexport const end = (store, action) => {\n  store.getState().players.forEach((player) => {\n    if (player.health <= 0) return\n\n    store.dispatch(\n      roll.failThen(\n        3,\n        player,\n        players.damage(player, 1000, {\n          from: { card: action.payload.card },\n        }),\n      ),\n    )\n  })\n}\n\nexport const shake = (store, action) => {\n  const previousState = store.getState()\n\n  previousState.players.forEach((player) => {\n    store.dispatch(\n      roll.failThen(\n        4,\n        player,\n        players.damage(player, previousState.activeCard.damage, {\n          card: previousState.activeCard,\n        }),\n      ),\n    )\n  })\n}\n\nexport const landslide = (store, action) => {\n  const { activeCard } = store.getState()\n\n  // find all tiles that are landslide and match the dice result\n  // tile should not be already in the landslide status\n  // add the status 'landslide' to these tiles\n  // and for each of these tiles, check a player is in it and damage it in this case\n  store.mutate((state) => {\n    state.grid.forEach((tile) => {\n      const { type, status, dices } = tile\n\n      if (type !== 'landslide') return\n      if (status.includes('landslide')) return\n      if (!dices.includes(action.payload.rolled)) return\n\n      tile.status.push('landslide')\n\n      state.players.forEach((player) => {\n        if (!isCellEqual(player)(tile)) return\n\n        store.dispatch(\n          players.damage(player, activeCard.damage, {\n            card: activeCard,\n          }),\n        )\n      })\n    })\n  })\n}\n\nexport const processMarkerCard = (store, action) => {\n  const { card } = action.payload\n\n  // find all tiles that have water type and put a status on it\n  // if it do not already exists\n  // if a player is in this tile then it take damage\n  store.mutate((state) => {\n    state.grid.forEach((tile) => {\n      const { type, status } = tile\n\n      if (type !== card.type) return\n      if (status.includes(card.type)) return\n\n      tile.status.push(card.type)\n\n      state.players.forEach((player) => {\n        if (!isCellEqual(player)(tile)) return\n\n        store.dispatch(\n          players.damage(player, card.damage, {\n            card,\n          }),\n        )\n      })\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"module"}