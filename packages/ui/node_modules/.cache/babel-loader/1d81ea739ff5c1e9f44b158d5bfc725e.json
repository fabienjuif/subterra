{"ast":null,"code":"// https://fr.wikipedia.org/wiki/Algorithme_A*\n// A* Search Algorithm\n// node: [x, y, cost, h, parentNode]\nfunction identity(o) {\n  return o;\n}\n\nfunction sortNodes(node1, node2) {\n  if (node1[3] > node2[3]) return 1;\n  if (node1[3] < node2[3]) return -1;\n  return 0;\n}\n\nfunction getFinalPath(end) {\n  if (!end[4]) return [end.slice(0, 3)];\n  return [...getFinalPath(end[4]), end.slice(0, 3)];\n}\n\nfunction defaultSameNode(node1, node2) {\n  return node1[0] === node2[0] && node1[1] === node2[1];\n}\n\nfunction defaultGetNeighbours(graph, node, {\n  mapNode = identity\n} = {}) {\n  const neighbours = []; // left\n\n  let next = graph[node[0] - 1] && graph[node[0] - 1][node[1]];\n  if (next) neighbours.push(mapNode(next)); // right\n\n  next = graph[node[0] + 1] && graph[node[0] + 1][node[1]];\n  if (next) neighbours.push(mapNode(next)); // top\n\n  next = graph[node[0]][node[1] - 1];\n  if (next) neighbours.push(mapNode(next)); // bottom\n\n  next = graph[node[0]][node[1] + 1];\n  if (next) neighbours.push(mapNode(next));\n  return neighbours;\n}\n\nfunction defaultDistance(node, end) {\n  const x = end[0] - node[0];\n  const y = end[1] - node[1];\n  return x * x + y * y;\n}\n\nmodule.exports = function getClosestPath(graph, start, end, {\n  sameNode = defaultSameNode,\n  mapGraph = identity,\n  mapNode = identity,\n  getNeighbours = defaultGetNeighbours,\n  distance = defaultDistance,\n  heuristic = () => 1,\n  maxLoops = Infinity\n} = {}) {\n  const mappedGraph = mapGraph([...graph].map(row => [...row].map(cell => [...cell])));\n  const closedList = [];\n  const openList = [];\n  openList.push(mapNode(start).concat(0));\n  let loop = -1;\n\n  while (openList.length > 0 && loop++ < maxLoops) {\n    const current = openList.shift();\n\n    if (current[2] === Infinity) {\n      return [-2, [], loop];\n    }\n\n    if (sameNode(current, end)) {\n      return [0, getFinalPath(current), loop];\n    }\n\n    const neighbours = getNeighbours(mappedGraph, current, {\n      mapNode\n    });\n\n    for (let i = 0; i < neighbours.length; i += 1) {\n      const neighbour = neighbours[i];\n      const known = neighbour[2] !== undefined;\n      if (closedList.find(n => sameNode(n, neighbour))) continue;\n      const newCost = (current[2] || 0) + heuristic(current.slice(0, 2), neighbour.slice(0, 2));\n      if (known && neighbour[2] < newCost) continue;\n      neighbour[2] = newCost;\n      neighbour[3] = neighbour[2] + distance(neighbour, end);\n      neighbour[4] = current;\n      if (!known) openList.push(neighbour);\n      openList.sort(sortNodes);\n    }\n\n    closedList.push(current);\n  }\n\n  if (loop >= maxLoops) {\n    return [1, getFinalPath(openList[0]), loop];\n  }\n\n  return [-1, [], loop];\n};","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/node_modules/@fabienjuif/astar/index.js"],"names":["identity","o","sortNodes","node1","node2","getFinalPath","end","slice","defaultSameNode","defaultGetNeighbours","graph","node","mapNode","neighbours","next","push","defaultDistance","x","y","module","exports","getClosestPath","start","sameNode","mapGraph","getNeighbours","distance","heuristic","maxLoops","Infinity","mappedGraph","map","row","cell","closedList","openList","concat","loop","length","current","shift","i","neighbour","known","undefined","find","n","newCost","sort"],"mappings":"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","sourcesContent":["// https://fr.wikipedia.org/wiki/Algorithme_A*\n// A* Search Algorithm\n\n// node: [x, y, cost, h, parentNode]\n\nfunction identity(o) {\n  return o\n}\nfunction sortNodes(node1, node2) {\n  if (node1[3] > node2[3]) return 1\n  if (node1[3] < node2[3]) return -1\n  return 0\n}\nfunction getFinalPath(end) {\n  if (!end[4]) return [end.slice(0, 3)]\n  return [...getFinalPath(end[4]), end.slice(0, 3)]\n}\nfunction defaultSameNode(node1, node2) {\n  return node1[0] === node2[0] && node1[1] === node2[1]\n}\n\nfunction defaultGetNeighbours(graph, node, { mapNode = identity } = {}) {\n  const neighbours = []\n\n  // left\n  let next = graph[node[0] - 1] && graph[node[0] - 1][node[1]]\n  if (next) neighbours.push(mapNode(next))\n\n  // right\n  next = graph[node[0] + 1] && graph[node[0] + 1][node[1]]\n  if (next) neighbours.push(mapNode(next))\n\n  // top\n  next = graph[node[0]][node[1] - 1]\n  if (next) neighbours.push(mapNode(next))\n\n  // bottom\n  next = graph[node[0]][node[1] + 1]\n  if (next) neighbours.push(mapNode(next))\n\n  return neighbours\n}\n\nfunction defaultDistance(node, end) {\n  const x = end[0] - node[0]\n  const y = end[1] - node[1]\n\n  return x * x + y * y\n}\n\nmodule.exports = function getClosestPath(\n  graph,\n  start,\n  end,\n  {\n    sameNode = defaultSameNode,\n    mapGraph = identity,\n    mapNode = identity,\n    getNeighbours = defaultGetNeighbours,\n    distance = defaultDistance,\n    heuristic = () => 1,\n    maxLoops = Infinity,\n  } = {},\n) {\n  const mappedGraph = mapGraph(\n    [...graph].map((row) => [...row].map((cell) => [...cell])),\n  )\n  const closedList = []\n  const openList = []\n\n  openList.push(mapNode(start).concat(0))\n\n  let loop = -1\n  while (openList.length > 0 && loop++ < maxLoops) {\n    const current = openList.shift()\n\n    if (current[2] === Infinity) {\n      return [-2, [], loop]\n    }\n\n    if (sameNode(current, end)) {\n      return [0, getFinalPath(current), loop]\n    }\n\n    const neighbours = getNeighbours(mappedGraph, current, { mapNode })\n    for (let i = 0; i < neighbours.length; i += 1) {\n      const neighbour = neighbours[i]\n      const known = neighbour[2] !== undefined\n\n      if (closedList.find((n) => sameNode(n, neighbour))) continue\n\n      const newCost =\n        (current[2] || 0) +\n        heuristic(current.slice(0, 2), neighbour.slice(0, 2))\n\n      if (known && neighbour[2] < newCost) continue\n\n      neighbour[2] = newCost\n      neighbour[3] = neighbour[2] + distance(neighbour, end)\n      neighbour[4] = current\n      if (!known) openList.push(neighbour)\n      openList.sort(sortNodes)\n    }\n\n    closedList.push(current)\n  }\n\n  if (loop >= maxLoops) {\n    return [1, getFinalPath(openList[0]), loop]\n  }\n\n  return [-1, [], loop]\n}\n"]},"metadata":{},"sourceType":"script"}