{"ast":null,"code":"import getClosestPath from '@fabienjuif/astar';\nimport { isCellEqual, canMoveFromTo } from './utils/tiles';\n\nconst mapGridToAstarGraph = grid => {\n  const graph = [];\n  grid.forEach(cell => {\n    if (!graph[cell.x]) graph[cell.x] = [];\n    if (!graph[cell.x][cell.y]) graph[cell.x][cell.y] = [cell.x, cell.y];\n  });\n  return graph;\n};\n\nexport const process = (store, action) => {\n  const previousState = store.getState();\n  const {\n    grid,\n    players\n  } = previousState; // find enemies\n\n  const enemies = grid.filter(({\n    status\n  }) => status.includes('enemy')) // if there is multiple enemies on the same tile we duplicates tiles\n  // for the rest of the function\n  .flatMap(tile => Array.from({\n    length: tile.status.filter(s => s === 'enemy').length\n  }).map(() => tile)); // map grid to a star graph\n\n  const graph = mapGridToAstarGraph(grid); // for each enemy get the closest player\n  // - get all path from enemy to each player\n  // - get the shortest path\n  // *  if the closest enemy is at more than 7 tiles, the enemy is dead (TODO:)\n  // *  if the shortest path is shared between multiple player\n  //    the enemy move toward the player with the lesser strengh\n\n  enemies.forEach(enemy => {\n    let shortestPath;\n    let closestPlayer;\n    players.forEach(player => {\n      const [status, path] = getClosestPath(graph, [enemy.x, enemy.y], [player.x, player.y], {\n        heuristic: (start, end) => {\n          if (canMoveFromTo(grid.find(isCellEqual({\n            x: start[0],\n            y: start[1]\n          })), grid.find(isCellEqual({\n            x: end[0],\n            y: end[1]\n          })))) return 1;\n          return Infinity;\n        }\n      });\n\n      if (status === 0) {\n        if (!shortestPath || path.length === shortestPath.length) {\n          if (!closestPlayer || closestPlayer.strength > player.strength) {\n            shortestPath = path;\n            closestPlayer = player;\n          }\n        } else if (path.length < shortestPath.length) {\n          shortestPath = path;\n          closestPlayer = player;\n        }\n      }\n    });\n\n    if (shortestPath && shortestPath.length > 1 && shortestPath.length < 7) {\n      store.dispatch({\n        type: '@enemies>move',\n        payload: {\n          enemy: {\n            x: enemy.x,\n            y: enemy.y\n          },\n          path: shortestPath.map(([x, y]) => ({\n            x,\n            y\n          })),\n          playerName: closestPlayer.name\n        }\n      });\n    } else {\n      store.dispatch({\n        type: '@enemies>kill',\n        payload: {\n          x: enemy.x,\n          y: enemy.y\n        }\n      });\n    }\n  });\n};\nexport const move = (store, action) => {\n  store.mutate(state => {\n    const previousCell = state.grid.find(isCellEqual(action.payload.enemy));\n    previousCell.status.splice(previousCell.status.findIndex(s => s === 'enemy'), 1);\n    const nextCell = state.grid.find(isCellEqual(action.payload.path[1]));\n    nextCell.status.push('enemy');\n  });\n};\nexport const kill = (store, action) => {\n  store.mutate(state => {\n    const cell = state.grid.find(isCellEqual(action.payload));\n    cell.status.splice(cell.status.findIndex(s => s === 'enemy'), 1);\n  });\n};","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/packages/engine/src/enemies.js"],"names":["getClosestPath","isCellEqual","canMoveFromTo","mapGridToAstarGraph","grid","graph","forEach","cell","x","y","process","store","action","previousState","getState","players","enemies","filter","status","includes","flatMap","tile","Array","from","length","s","map","enemy","shortestPath","closestPlayer","player","path","heuristic","start","end","find","Infinity","strength","dispatch","type","payload","playerName","name","move","mutate","state","previousCell","splice","findIndex","nextCell","push","kill"],"mappings":"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","sourcesContent":["import getClosestPath from '@fabienjuif/astar'\nimport { isCellEqual, canMoveFromTo } from './utils/tiles'\n\nconst mapGridToAstarGraph = (grid) => {\n  const graph = []\n\n  grid.forEach((cell) => {\n    if (!graph[cell.x]) graph[cell.x] = []\n    if (!graph[cell.x][cell.y]) graph[cell.x][cell.y] = [cell.x, cell.y]\n  })\n\n  return graph\n}\n\nexport const process = (store, action) => {\n  const previousState = store.getState()\n  const { grid, players } = previousState\n\n  // find enemies\n  const enemies = grid\n    .filter(({ status }) => status.includes('enemy'))\n    // if there is multiple enemies on the same tile we duplicates tiles\n    // for the rest of the function\n    .flatMap((tile) =>\n      Array.from({\n        length: tile.status.filter((s) => s === 'enemy').length,\n      }).map(() => tile),\n    )\n\n  // map grid to a star graph\n  const graph = mapGridToAstarGraph(grid)\n\n  // for each enemy get the closest player\n  // - get all path from enemy to each player\n  // - get the shortest path\n  // *  if the closest enemy is at more than 7 tiles, the enemy is dead (TODO:)\n  // *  if the shortest path is shared between multiple player\n  //    the enemy move toward the player with the lesser strengh\n  enemies.forEach((enemy) => {\n    let shortestPath\n    let closestPlayer\n\n    players.forEach((player) => {\n      const [status, path] = getClosestPath(\n        graph,\n        [enemy.x, enemy.y],\n        [player.x, player.y],\n        {\n          heuristic: (start, end) => {\n            if (\n              canMoveFromTo(\n                grid.find(isCellEqual({ x: start[0], y: start[1] })),\n                grid.find(isCellEqual({ x: end[0], y: end[1] })),\n              )\n            )\n              return 1\n            return Infinity\n          },\n        },\n      )\n\n      if (status === 0) {\n        if (!shortestPath || path.length === shortestPath.length) {\n          if (!closestPlayer || closestPlayer.strength > player.strength) {\n            shortestPath = path\n            closestPlayer = player\n          }\n        } else if (path.length < shortestPath.length) {\n          shortestPath = path\n          closestPlayer = player\n        }\n      }\n    })\n\n    if (shortestPath && shortestPath.length > 1 && shortestPath.length < 7) {\n      store.dispatch({\n        type: '@enemies>move',\n        payload: {\n          enemy: {\n            x: enemy.x,\n            y: enemy.y,\n          },\n          path: shortestPath.map(([x, y]) => ({ x, y })),\n          playerName: closestPlayer.name,\n        },\n      })\n    } else {\n      store.dispatch({\n        type: '@enemies>kill',\n        payload: {\n          x: enemy.x,\n          y: enemy.y,\n        },\n      })\n    }\n  })\n}\n\nexport const move = (store, action) => {\n  store.mutate((state) => {\n    const previousCell = state.grid.find(isCellEqual(action.payload.enemy))\n    previousCell.status.splice(\n      previousCell.status.findIndex((s) => s === 'enemy'),\n      1,\n    )\n\n    const nextCell = state.grid.find(isCellEqual(action.payload.path[1]))\n    nextCell.status.push('enemy')\n  })\n}\n\nexport const kill = (store, action) => {\n  store.mutate((state) => {\n    const cell = state.grid.find(isCellEqual(action.payload))\n    cell.status.splice(\n      cell.status.findIndex((s) => s === 'enemy'),\n      1,\n    )\n  })\n}\n"]},"metadata":{},"sourceType":"module"}