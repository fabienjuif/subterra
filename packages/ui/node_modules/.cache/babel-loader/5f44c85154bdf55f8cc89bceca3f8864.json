{"ast":null,"code":"import React, { createContext, useContext // we use layout effect so we are sure that per default there is no clipping\n// and action like \"mount\" are sent right away\n// if you want to delay a state update, you can wrap our custom hook into yours\n// and use an useEffect\n, useLayoutEffect, useState } from 'react'; // eslint-disable-line import/no-unresolved\n\nimport { getFromPath } from '@myrtille/util';\nexport const Context = createContext();\nexport const provider = store => Component => props => {\n  useLayoutEffect(() => {\n    store.dispatch('@@react/MOUNT');\n    return () => {\n      store.dispatch('@@react/UNMOUNT');\n    };\n  }, []);\n  return React.createElement(Context.Provider, {\n    value: store\n  }, React.createElement(Component, props));\n};\nexport const Provider = ({\n  store,\n  children\n}) => React.createElement(Context.Provider, {\n  value: store\n}, React.cloneElement(children));\nexport const useStore = () => useContext(Context);\nexport const useDispatch = () => {\n  const store = useContext(Context);\n  return store.dispatch;\n};\nexport const useListeners = (listeners = []) => {\n  const store = useContext(Context);\n  useLayoutEffect(() => {\n    const unregisters = listeners.map(([matcher, mutator]) => store.addListener(matcher, mutator));\n    return () => {\n      unregisters.forEach(unregister => unregister());\n    };\n  }, [store]);\n};\nexport const useStateAt = path => {\n  const store = useContext(Context);\n  const [state, setState] = useState(getFromPath(store.getState(), path));\n  useLayoutEffect(() => store.subscribe(path, () => setState(getFromPath(store.getState(), path))), []);\n  return state;\n};","map":{"version":3,"sources":["/home/fabienjuif/work/subterra/node_modules/@myrtille/react/index.js"],"names":["React","createContext","useContext","useLayoutEffect","useState","getFromPath","Context","provider","store","Component","props","dispatch","createElement","Provider","value","children","cloneElement","useStore","useDispatch","useListeners","listeners","unregisters","map","matcher","mutator","addListener","forEach","unregister","useStateAt","path","state","setState","getState","subscribe"],"mappings":"AAAA,OAAOA,KAAP,IACEC,aADF,EAEEC,UAFF,CAGE;AACA;AACA;AACA;AANF,EAOEC,eAPF,EAQEC,QARF,QASO,OATP,C,CASe;;AACf,SAASC,WAAT,QAA4B,gBAA5B;AAEA,OAAO,MAAMC,OAAO,GAAGL,aAAa,EAA7B;AAEP,OAAO,MAAMM,QAAQ,GAAIC,KAAD,IAAYC,SAAD,IAAgBC,KAAD,IAAW;AAC3DP,EAAAA,eAAe,CAAC,MAAM;AACpBK,IAAAA,KAAK,CAACG,QAAN,CAAe,eAAf;AACA,WAAO,MAAM;AACXH,MAAAA,KAAK,CAACG,QAAN,CAAe,iBAAf;AACD,KAFD;AAGD,GALc,EAKZ,EALY,CAAf;AAOA,SAAOX,KAAK,CAACY,aAAN,CACLN,OAAO,CAACO,QADH,EAEL;AAAEC,IAAAA,KAAK,EAAEN;AAAT,GAFK,EAGLR,KAAK,CAACY,aAAN,CAAoBH,SAApB,EAA+BC,KAA/B,CAHK,CAAP;AAKD,CAbM;AAeP,OAAO,MAAMG,QAAQ,GAAG,CAAC;AAAEL,EAAAA,KAAF;AAASO,EAAAA;AAAT,CAAD,KAAyBf,KAAK,CAACY,aAAN,CAC/CN,OAAO,CAACO,QADuC,EAE/C;AAAEC,EAAAA,KAAK,EAAEN;AAAT,CAF+C,EAG/CR,KAAK,CAACgB,YAAN,CAAmBD,QAAnB,CAH+C,CAA1C;AAMP,OAAO,MAAME,QAAQ,GAAG,MAAMf,UAAU,CAACI,OAAD,CAAjC;AAEP,OAAO,MAAMY,WAAW,GAAG,MAAM;AAC/B,QAAMV,KAAK,GAAGN,UAAU,CAACI,OAAD,CAAxB;AAEA,SAAOE,KAAK,CAACG,QAAb;AACD,CAJM;AAMP,OAAO,MAAMQ,YAAY,GAAG,CAACC,SAAS,GAAG,EAAb,KAAoB;AAC9C,QAAMZ,KAAK,GAAGN,UAAU,CAACI,OAAD,CAAxB;AAEAH,EAAAA,eAAe,CAAC,MAAM;AACpB,UAAMkB,WAAW,GAAGD,SAAS,CAACE,GAAV,CAAc,CAAC,CAACC,OAAD,EAAUC,OAAV,CAAD,KAAwBhB,KAAK,CAACiB,WAAN,CAAkBF,OAAlB,EAA2BC,OAA3B,CAAtC,CAApB;AAEA,WAAO,MAAM;AACXH,MAAAA,WAAW,CAACK,OAAZ,CAAqBC,UAAD,IAAgBA,UAAU,EAA9C;AACD,KAFD;AAGD,GANc,EAMZ,CAACnB,KAAD,CANY,CAAf;AAOD,CAVM;AAYP,OAAO,MAAMoB,UAAU,GAAIC,IAAD,IAAU;AAClC,QAAMrB,KAAK,GAAGN,UAAU,CAACI,OAAD,CAAxB;AACA,QAAM,CAACwB,KAAD,EAAQC,QAAR,IAAoB3B,QAAQ,CAACC,WAAW,CAACG,KAAK,CAACwB,QAAN,EAAD,EAAmBH,IAAnB,CAAZ,CAAlC;AAEA1B,EAAAA,eAAe,CACb,MAAMK,KAAK,CAACyB,SAAN,CAAgBJ,IAAhB,EAAsB,MAAME,QAAQ,CAAC1B,WAAW,CAACG,KAAK,CAACwB,QAAN,EAAD,EAAmBH,IAAnB,CAAZ,CAApC,CADO,EAEb,EAFa,CAAf;AAKA,SAAOC,KAAP;AACD,CAVM","sourcesContent":["import React, {\n  createContext,\n  useContext,\n  // we use layout effect so we are sure that per default there is no clipping\n  // and action like \"mount\" are sent right away\n  // if you want to delay a state update, you can wrap our custom hook into yours\n  // and use an useEffect\n  useLayoutEffect,\n  useState,\n} from 'react' // eslint-disable-line import/no-unresolved\nimport { getFromPath } from '@myrtille/util'\n\nexport const Context = createContext()\n\nexport const provider = (store) => (Component) => (props) => {\n  useLayoutEffect(() => {\n    store.dispatch('@@react/MOUNT')\n    return () => {\n      store.dispatch('@@react/UNMOUNT')\n    }\n  }, [])\n\n  return React.createElement(\n    Context.Provider,\n    { value: store },\n    React.createElement(Component, props),\n  )\n}\n\nexport const Provider = ({ store, children }) => React.createElement(\n  Context.Provider,\n  { value: store },\n  React.cloneElement(children),\n)\n\nexport const useStore = () => useContext(Context)\n\nexport const useDispatch = () => {\n  const store = useContext(Context)\n\n  return store.dispatch\n}\n\nexport const useListeners = (listeners = []) => {\n  const store = useContext(Context)\n\n  useLayoutEffect(() => {\n    const unregisters = listeners.map(([matcher, mutator]) => store.addListener(matcher, mutator))\n\n    return () => {\n      unregisters.forEach((unregister) => unregister())\n    }\n  }, [store])\n}\n\nexport const useStateAt = (path) => {\n  const store = useContext(Context)\n  const [state, setState] = useState(getFromPath(store.getState(), path))\n\n  useLayoutEffect(\n    () => store.subscribe(path, () => setState(getFromPath(store.getState(), path))),\n    [],\n  )\n\n  return state\n}\n"]},"metadata":{},"sourceType":"module"}